## 함수형 프로그래밍과 단위 테스트

- 함수형 프로그래밍 방식을 적용하는 것만으로도 자연스레 코드를 잘게 쪼개어 작성하게 된다.
- 하나의 함수가 하나의 일만 수행하는 "단일 책임 원칙"이 자연스럽게 적용되어, 테스트 코드를 작성함에 있어서도 각 함수 하나씩만 테스트해도 어플리케이션에 대한 신뢰도가 충분히 오를 수 있다.
- 함수형 프로그래밍에서는, 함수가 "상태값"을 가지지 않기 때문에 어떤 "상태값"에 따라 실행이 변할 수 있는 명령형 코드보다 테스트에 이점을 갖는다.

아래는 함수형 프로그래밍이 명령형 프로그래밍에 비해 테스트에서 이점을 갖는 부분이다.

1. 기능이 단위로 분리되어 있기 떄문에, 한 번에 하나의 기능에 대해서만 테스트하면 된다.
2. 각 기능이 외부 값의 상태에 독립적이기 때문에, 테스트하기에 용이하다.
3. 독립적이기 때문에 또한, 테스트 순서가 비즈니스 로직과 무관하여도 문제가 없다.

## "불순한 코드"의 테스트

함수형 프로그래밍은 기본적으로 "순수 함수"를 지향한다고 했지만, 실전에서는 모든 함수를 "순수 함수"로 만들 수는 없다. 클라이언트 쪽에서는 대표적으로 브라우저의 DOM을 조작하는 부분이 필수적으로 들어가게 되고, 서버 쪽에서는 데이터베이스나 파일을 참조하여 외부 데이터를 불러올 수밖에 없다.

여기서 DOM 조작과 같은 부분은 실질적으로 우리가 테스트할 수 있는 부분은 아니고, 서버 쪽의 데이터 처리 등은 Mocking을 통하면 테스트하기 편리하다. 실제 데이터 통신이 있는 부분을 제거하여, 올바른 값을 가져왔다는 것을 가정하고 코드를 작성하면 테스트가 가능해진다.

## 테스트와 코드 실행률

- 테스트를 작성하고, 실행시키는 데 있어서 전체 코드 라인 중에서, 테스트 중에 얼마나 많은 부분이 실행되었는가를 "코드 실행률"이라 표시할 수 있다.
- 예외처리나, 조건문으로 인해 실행률이 100%가 될 일은 거의 없지만, 실행률이 높아야 작성된 코드가 그만큼 충분히 테스트되었다고도 볼 수 있다.
- 함수형 프로그래밍은, 모나드와 같은 개념을 이용하여 코드 실행을 중단하지 않기 때문에, 코드의 실행 과정을 최대한 덜 건너뛰는 테스트를 실행할 수가 있다.
- [!] 잘못된 값이 들어왔을 때, 명령형 코드나 함수형 코드나 실제로 건너뛰는 로직 자체는 동일하지만, 함수형의 라인 수가 더 많아서 코드 실행률이 상대적으로 높음
- [!] 실제로 비즈니스 로직과 관련이 없는 함수 선언 라인들이 추가되었을 뿐인데 이것으로 코드 실행률이 오른 것이 무슨 의미가 있는지 모르겠음
- [!] 코드 실행률을 높이면서 모듈화가 강제? 되기? 때문에? 코드? 실행률을 높이는게? 좋다는 뜻일까?

---

## 함수형 프로그래밍의 성능 최적화

- 함수형으로 코드를 작성하는 것이 명령형보다 더 성능이 뛰어날까?
- 주요 키워드들
  - 지연 평가 (Lazy Evaluation)
  - 메모화 (Memorization)
  - 꼬리 호출 최적화 (Tail Call Optimization)

## Context Stack

- 자바스크립트 코드에서 실행되는 함수들은, depth가 깊어질 때마다 컨텍스트 스택에 새 데이터(함수 컨텍스트)를 push하게 된다.
- curry된 함수는, 여러 함수를 중첩하여 작성하는 꼴이 되기 때문에 컨텍스트 스택에 상대적으로 더 많은 데이터를 쌓게 되고, 메모리를 더 많이 사용하게 된다.
- 하지만 코드 상에서 작성될 때의 이점이 있으니, 장점과 단점을 잘 저울질해보면 될 것 (대부분은 엄청나게 많은 재귀를 하지 않기 때문에 큰 성능적인 차이가 생기진 않을 것)

## 지연 평가

- 자바스크립트는 기본적으로, 어떤 연산을 실행하면 연산의 결과값이 언제 다시 호출되어 사용될 지에 상관없이, 바로 연산을 수행한다.
- 이를 조급한 평가(Eager Evaluation), 또는 탐욕적인 평가(Greedy Evaluation)라고 부른다.
- lodash의 `take(n: number)` 함수는 map이나 filter로 넘겨진 데이터 중 n개만을 가져오기 때문에, n번째 이후의 데이터에 대해서는 map이나 filter를 적용하지 않아 불필요한 연산을 하지 않게 된다.

## 메모화

- 연산이 잦은 함수들은, 함수 내부에 자체적인 캐시(단순 key-val 형태 객체로도 구현 가능)를 만드는 것으로 추가적인 반복 연산에 비용을 절감할 수 있다.
- 매개변수가 많은 함수는, 커링된 함수를 메모화하는 방법을 사용할 수도 있다.

## 꼬리 호출 최적화

- 재귀 함수는 기본적으로 한 함수를 여러 depth에 걸쳐 실행하게 되는데, 재귀 실행의 부분을 함수의 끝부분으로 두는 기법을 "꼬리 호출"이라고 한다.
  ```js
  const factorial = (n, current) => {
    n === 1 ? current : factorial(n - 1, current * n);
  };
  ```
- 위와 같이 코드를 작성하면, 재귀가 실행되는 부분이 코드의 맨 끝이기 때문에 스택이 중첩되지 않고, 함수 실행에 대한 스택을 한 개만 사용하고도 재귀 호출이 가능하다.

---

## 비동기 호출

- 이미 알고 있는 개념들인 것 같다?? 지금은 async-await 구문도 사용할 수 있고, 또한 compose에 비동기 로직도 적용할 수 있어 콜백 지옥을 회피할 수 있는 방법이 충분함
